ifndef::sourcedir[]
include::common.adoc[]
endif::sourcedir[]

= Custom Serializers

The Getting Started document gives you an overview of how to use custom serializers with a cache. This document explains
how you can write a custom serilaizer that works with Ehcache. Here we discuss the significance of serializer
annotations `Transient` and `Persistent` in detail and what they actually mean. Let's get started.

== Serializer annotations

In the getting started document you must have already seen the seriaizers annotated as `Persistent` and `Transient`. The
doc further explains that the `Transient` annotation marks a seriliazer fit to be used with transient caches and the
`Persistent` annotation for serializers that can be used with persistent caches. Hmm... So what does that really mean?
If you look at the custom serializer implementations in the GettingStarted samples they are all marked both `Transient`
and `Persistent` and if you look at the code they don't do anything different. It's all standard java serialization. So 
why are they marked both transient and persistent at the same time? What is `Transient` only serializer? How do I
implement a `Persistent` only serializer? Why would I ever do all this? Read along for the answers to these questions.

These annotations are associated with the state of the serializer implementations. So if your custom serializer doesn't
have any state associated with it that affects the serialization and deserialization logic, then that is a serializer 
implementation that can safely be used with transient and persistent caches. Such serializers are annotated as both
`Transient` and `Persistent`. If you look at the `LongSerializer` or `StringSerializer` implementations in the 
GettingStarted samples, they don't have any state that the serialization and deserialization depend on.

So what are these serializers with *state*? I'll try to explain that with some examples in the subsequent sections.

=== Transient serializers

I have an application that deals with fruits. So I have a _fruits_ cache `Cache<Long, String>` that holds the mappings
from fruit ids to fruit names. If this cache is a multi-tiered one then the keys and values will be stored in their 
serialized form in the authoritative-tier. For simplicity I'll restrict the scope of our discussion only to the values
that are fruit names of type `String`. I can use standard Java serialization to serialize these values. But for some
reason I wanted to reduce the amount of serialized data. So instead of serializing the strings directly I decided to map
all the fruit names to some integer and store those serialized integers instead of strings thinking that it'd save some
space(dumb, huh???). And here is the serializer implementation that I came up with:

[source,java,indent=0]
----
include::{sourcedir}/impl/src/test/java/org/ehcache/docs/serializers/DumbTransientStringSerializer.java[tag=transientSerializer]
----

In short this is what the above serializer does: Whenever it gets a string(the fruit name, in our application) to be
serialized it checks if there is a mapping that exists already for that name in *stringIdMap*. If yes, the mapped
integer is retrieved from the map and that integer value is serialized. If a mapping is not found, we generate a new 
*id* for the new fruit name add it to both the maps that we preserve(*stringIdMap* and *idStringMap*) and then serialize
this newly generated id. Now on deserialization, the same *idStringMap* map is used to retrieve the fruit names from the
deserialized integer values.

So in the above serializer, the *idStringMap*, *stringIdMap* and the *id* constitutes the _state_ of the serializer. The
serialization and deserialization depends on this state and would not work properly without that state. So now that we
have a state-full serializer understanding the `Transient` and `Persistent` annotations would be simpler.

Here is a sample code that uses the `DumbTransientStringSerializer` with a cache:

[source,java,indent=0]
----
include::{sourcedir}/impl/src/test/java/org/ehcache/docs/serializers/SerializersDemo.java[tag=transientSerializerGoodSample]
----

<1> Create a multi-tiered cache that depends on key and value serialization.
<2> Configure a serializer for the values. The `DumbTransientStringSerializer` in this case. For the sake of simplicity
    we have omitted key serializer. Since one is not provided explicitly, ehcache would provide default serializers to
    perform the key serialization.
<3> Verify that the cache/serializer works.

In the previous section we demonstrated the use of a transient serializer. We used that serializer with a transient
cache and everything works just fine. Now imagine what would happen if we use the same serializer with a persistent
cache. Everything would work as long as your application is running. Once you close the cache manager or end the
application the data associated with the cache will be persisted so that the same data will be available on a restart.
But there is a serious problem. The following piece of code would demonstrate that:

[source,java,indent=0]
----
include::{sourcedir}/impl/src/test/java/org/ehcache/docs/serializers/SerializersDemo.java[tag=transientSerializerBadSample]
----

<1> Create a cache configuration with persistent disk tier.
<2> Configure the `LocalPersistenceService` for the cache manager.
<3> Retrieve the cache.
<4> Populate data.
<5> Verify that everything works.
<6> Close the cache manager.
<7> Reinitialize the cache manager.
<8> Retrieve the cache.
<9> Retrieve a cached/persisted value.

The above piece of code would fail in step 9 because the cache will not be able to retrieve the persisted data. But why?
Because the serializer that you provided fails in retrieving that data. When the cache is reinitialized, the associated
serializer instance is also initialized for the cache to work. But the newly initialized serializer would have an
empty state(empty *stringIdMap* and *idStringMap* maps and the *id* initialized to 0). So when the cache tries to read a
value it gets an integer value from the persistent tier as that is what got persisted. But using the empty state the 
serializer will not able to map that value to a fruit name, and so it throws. That leaves the persisted data unusable.
So what could you have done differently to make it work? The answer is simple. Persist the serializer's state as well.
And that is exactly what persistent serializers would do.

=== Persistent serializers

A persistent serializer persists its state and retrieves it when reinitialized. A persistent serializer implementation
can choose to persist the data wherever it wants. But a recommended way is to use the cache manager's
`LocalPersistenceService` so that the cache manager would take care of the persistence. Inorder to do that, the
serializer implementation needs to have a constructor that takes in a `FileBasedPersistenceContext` as an argument, in
addition to the mandatory class loader argument. And of course the serializer needs to be annotated as `Persistent`.
Have a look at this dummy implementation of a persistent serializer. It is just an extension of the same old transient
serializer with the persistent stuff wired in.

[source,java,indent=0]
----
include::{sourcedir}/impl/src/test/java/org/ehcache/docs/serializers/DumbPersistentStringSerializer.java[tag=persistentSerializer]
----

In the above persistent serializer the state or the serialization/deserialization has not changed. The only additional
thing is the persistence logic. And that is fairly simple too. The state is restored on initialization if one is found,
and persisted on close. And have a look at the sample from the previous section modified to use our persistent
serializer.

[source,java,indent=0]
----
include::{sourcedir}/impl/src/test/java/org/ehcache/docs/serializers/SerializersDemo.java[tag=persistentSerializerGoodSample]
----

<1> The only change from the previous sample is the usage of `DumbPersistentStringSerializer` here.